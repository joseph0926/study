# 실험 1.3: try/catch 없이 Stack Overflow

## 최상위 질문

try/catch로 잡히지 않은 RangeError는 어떻게 동작하는가?

## 실험 1.2와의 차이

**실험 1.2**:

```javascript
try {
  recursion();
} catch (e) {
  // 에러를 잡아서 처리
}
```

**실험 1.3**:

```javascript
recursion(); // try/catch 없음!
console.log("이 줄은 실행될까?");
```

## 실험 코드

```javascript
let count = 0;

function recursion() {
  count++;
  recursion();
}

console.log("=== 실험 시작 ===");
recursion();
console.log("=== 실험 종료 ==="); // 이 줄은 실행될까?
console.log(`최종 count: ${count}`);
```

## 당신의 예측

**"실험 종료" 메시지가 출력되는가?**

```
실행 안될것
```

**브라우저 상태는?**

```
A) 정상 작동 (에러만 콘솔에 표시)
B) 스크립트 중단 (이후 코드 실행 안됨)
C) 탭 프리징
D) 브라우저 크래시

B
```

**예측한 이유:**

```
- try/catch가 없으므로 에러를 잡아서 확인 할 수는 없지만 에러는 Range Error는 발생할것 -> 에러가 발생하면 스크립트는 중단될것
```

**대안 가설 (최소 1개 이상):**

```
혹시 다르게 동작할 가능성은?

- 에러가 발생해도 try/catch로 에러 처리를 하지 않아서 계속 실행되어 브라우저 프리징 발생?
```

---

## 사고 체크 (교정 받을 영역)

**핵심 질문:**

- [ ] "Uncaught Error"는 프로그램을 완전히 중단시키는가?
- [ ] 실험 1.2에서 try/catch가 정확히 무엇을 막았는가?
- [ ] "브라우저가 죽는다"와 "스크립트가 중단된다"의 차이는?

**검증할 가정:**

- [ ] Uncaught Error = 브라우저 크래시?
- [ ] 에러 후 다음 줄이 실행되지 않는 이유는?

---

## 실험 실행

(아래는 실험 후 작성)

**실제 결과:**

```
Uncaught RangeError: Maximum call stack size exceeded
```

**관찰:**

```
- "실험 종료"가 출력되었는가? > 아니요
- count 값이 출력되었는가? > 아니요
- 브라우저 상태는? > 정상
- 실험 1.2와 다른 점은? > Uncaught 라는 표현이 추가됨 > 즉 잡지않은(처리하지않은)에러라는 뜻
```

---

## 분석

**예측과 일치/불일치:**

```
- 일치
```

**왜 그런 결과가 나왔는가?**

```
- 에러가 js에러이고 js는 에러가 발생하면 js 스크립트 실행이 중단됨
```

**실험 1.2와의 차이:**

```
try/catch가 있을 때: (실험 1.2 결과)
try/catch가 없을 때: (실험 1.3 결과)

차이점: 에러를 명시적으로 잡아서 처리함의 차이
```

**틀렸다면, 어떤 가정이 잘못되었나?**

```
(틀린 경우에만 작성)
```

---

## 새로운 질문

**이 실험에서 생긴 새로운 의문:**

```
- 리액트 무한 리렌더링은 왜 에러 발생으로 안끝나고 브라우저가 죽는지? > 다만 이 질문은 js 학습 범위를 벗어나는거같음
```

**다음 실험 아이디어:**

```
(실험 후 작성)
```

---

## 실험 1.2와의 연결

**실험 1.2에서 배운 것:**

- Call Stack 한계: ~10,364번
- 에러 타입: RangeError
- try/catch로 에러를 잡으면 프로그램 계속 실행

**실험 1.3에서 검증할 것:**

- try/catch 없으면 어떻게 되는가?
- "브라우저가 죽는" 경험과의 연결
