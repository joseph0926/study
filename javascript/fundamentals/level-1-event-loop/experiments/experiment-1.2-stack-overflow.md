# 실험 1.2: Call Stack의 한계

## 최상위 질문

Call Stack에 함수가 무한히 쌓일 수 있는가?

## 실험 코드

```javascript
let count = 0;

function recursion() {
  count++;
  recursion();
}

try {
  recursion();
} catch (e) {
  console.log(`${count}번째 호출에서 에러 발생`);
  console.log("에러 타입:", e.name);
  console.log("에러 메시지:", e.message);
}
```

## 당신의 예측

**에러가 발생하는가?**

```
에러가 발생하지 않을것같음
```

**발생한다면, 몇 번째 호출에서?**

```
모르겠음
```

**에러 이름은 무엇인가?**

```
모르겠음
```

**예측한 이유:**

```
- 제 경험상 로직이 꼬여서 무한 리렌더링이나(리엑트에서), 무한 패치(네트워크 요청)이 발생하면 계속 실행되다가 어느 순간 브라우저가 멈추고 꺼집니다.
- 위 경험을 통해 예측해보면, 에러가 발생해서 멈추거나 죽는게 아닌 계속 실행하다가 더이상 처리가 불가능하면 멈추거나 죽는거같습니다.
```

**대안 가설 (최소 1개 이상):**

```
혹시 다르게 동작할 가능성은?

- 위에서 죽거나 멈추는 이유가 에러가 발생해서 죽는것이고 && 위 경험에서 에러가 명시적으로 보이지 않았던 이유가 try/catch나 로그를 찍지 않아서라면?
```

---

## 사고 체크 (교정 받을 영역)

**사용한 용어 점검:**

- [ ] "무한히"라는 표현이 정확한가?
- [ ] "에러"와 "중단"의 차이를 구분했는가?
- [ ] "몇 번째"를 예측할 때 어떤 기준을 사용했는가?

**가정 점검:**

- [ ] Call Stack의 크기가 고정되어 있다고 가정했는가?
- [ ] 브라우저/환경마다 다를 수 있다고 고려했는가?

---

## 실험 실행

(아래는 실험 후 작성)

**실제 결과:**

```
- 10364번째 호출에서 에러 발생
- 에러 타입: RangeError
- 에러 메시지: Maximum call stack size exceeded
```

**관찰:**

```
- 예상: 에러가 발생하지 않거나 발생해도 javascript 에러가 아닌 브라우저 내부의 처리 한계를 넘어서는 브라우저 에러로 예상하였음
- 실제: 에러가 발생하고, javascript 에러임 > 자바스크립트의 콜스택에는 최대 사이즈가 존재하고 그 사이즈를 넘어가면 에러를 발생시킴
```

---

## 분석

**예측과 일치/불일치:**

```
불일치
```

**왜 그런 결과가 나왔는가?**

```
- 콜스택에는 최대 수용 사이즈가 존재하고 그걸 넘어가면 Range Error를 발생시킴
```

**틀렸다면, 어떤 가정이 잘못되었나?**

```
- 콜스택에는 최대 수용 사이즈가 존재한다는 사실을 몰랐음
```

---

## 새로운 질문

**이 실험에서 생긴 새로운 의문:**

```
- 만약 try/catch가 없다면? > 에러는 발생하겠지만 잡히지는 않을것 > 그러면 앞서 제가 관찰했던 "어느 순가 브라우저가 죽음"이 발생하는지?
- 최대 사이즈보다 약간 작으면? (극단적으로 10360번째까지만 실행하면)
```

**다음 실험 아이디어:**

```
(실험 후 작성)
```

---

## 실험 1.1과의 연결

**실험 1.1에서 배운 것:**

- 함수가 return하면 Call Stack에서 제거됨

**실험 1.2에서 검증할 것:**

- return하지 않고 계속 쌓이면?
- Call Stack의 물리적 한계는?
