# 실험 2.2: 블로킹 코드가 타이머에 미치는 영향

## 최상위 질문

Call Stack이 블로킹되어 있을 때, setTimeout의 타이머는 계속 진행되는가?

---

## 실험 코드

```javascript
console.log('시작');
setTimeout(() => console.log('timeout'), 1000);
console.log('블로킹 시작');
const start = Date.now();
while (Date.now() - start < 3000) {} // 3초 블로킹
console.log('블로킹 끝');
```

---

## 당신의 예측

**질문 1: "timeout"은 언제 출력되는가?**

```
약 3초 후 (블로킹 완료 직후)
```

**예측한 이유:**

```
1. setTimeout 실행:
   - setTimeout 자체는 동기 함수 → 즉시 Call Stack에 올라감
   - 타이머 시작 (1초 카운트)
   - 콜백을 Task Queue에 등록
   - 즉시 return → Call Stack에서 제거

2. 타이머는 백그라운드에서 진행:
   - 브라우저의 타이머 쓰레드가 담당
   - Call Stack이 블로킹되어도 타이머는 계속 진행
   - 1초 후 타이머 완료 → 콜백은 Task Queue에서 대기

3. while 루프 실행:
   - Call Stack에 올라가서 3초 동안 점유
   - 이 동안 Call Stack은 비어있지 않음
   - Event Loop는 Call Stack이 비어야 Task Queue의 콜백을 실행 가능

4. while 완료:
   - Call Stack 비어짐
   - Event Loop가 Task Queue에서 콜백을 가져와 Call Stack에 PUSH
   - "timeout" 출력

결론: 타이머는 1초에 완료되지만, 콜백 실행은 Call Stack이 비는 3초 후
```

**대안 가설 (최소 1개 이상):**

```
대안 1: 1초 후 출력
- 타이머가 완료되면 while과 관계없이 즉시 실행?
- 가능성: 낮음 (싱글쓰레드이므로 동시 실행 불가)

대안 2: 4초 후 출력 (1초 + 3초)
- 타이머가 while 블로킹 동안 멈춤?
- while 완료 후 나머지 1초 카운트?
- 가능성: 낮음 (타이머는 백그라운드에서 진행)
```

---

## 사고 체크 (교정 받을 영역)

**사용한 용어 점검:**

- [x] "먼저/나중" 같은 모호한 표현 사용했는가?
  - "1초 후", "3초 후" 등 구체적 시점 명시
- [x] 정확한 시점을 명시했는가?
  - "Call Stack이 비는 시점" 명시
- [x] "비동기" 같은 포괄적 용어 대신 구체적으로 설명했는가?
  - "Task Queue", "Event Loop", "Call Stack" 사용

**논리 점검:**

- [x] 예측과 이유가 논리적으로 일관되는가?
- [x] 모순되는 진술이 있는가?
  - 없음

**가정 점검:**

- [x] 숨겨진 가정이 있는가?
  - 가정: 타이머는 백그라운드에서 진행 (검증 필요!)
  - 가정: Event Loop는 Call Stack이 비어야 작동
- [x] 그 가정은 검증 가능한가?
  - 이번 실험으로 검증 가능
- [x] 실험 2.1의 결과를 고려했는가?
  - setTimeout의 콜백이 Task Queue에 등록됨을 고려

---

## 실험 실행

**실제 결과:**

```
(실험 후 콘솔 출력을 정확히 기록)
- "시작" 출력 시각:
- "블로킹 시작" 출력 시각:
- "블로킹 끝" 출력 시각:
- "timeout" 출력 시각:
```

**관찰:**

```
- 예측과 일치하는가?
- "timeout"이 정확히 언제 출력되었는가?
- 브라우저 상태는? (3초 동안 프리징?)
- 특이사항은?
```

---

## 분석

**예측과 일치/불일치:**

```
일치 / 불일치
```

**왜 그런 결과가 나왔는가?**

```
(원인 분석)
1. 타이머의 동작 방식:
   -

2. Call Stack과의 관계:
   -

3. Event Loop의 역할:
   -
```

**틀렸다면, 어떤 가정이 잘못되었나?**

```
(틀린 경우에만 작성)
- 가정 1이 틀렸음: ...
- 실제로는 ...
```

---

## 새로운 질문

**이 실험에서 생긴 새로운 의문:**

```
- 질문 1: setTimeout의 시간은 "최소 지연 시간"인가?
- 질문 2: 브라우저는 몇 개의 쓰레드를 사용하는가?
- 질문 3: 타이머를 담당하는 것은 무엇인가?
```

**다음 실험 아이디어:**

```
- 실험 아이디어 1: 여러 개의 setTimeout이 동시에 있을 때 순서는?
- 실험 아이디어 2: Promise와 setTimeout의 우선순위는?
```

---

## 이전 실험과의 연결

**실험 2.1에서 배운 것:**

- setTimeout 자체는 동기 함수
- setTimeout의 콜백만 Task Queue에 등록
- Call Stack이 비면 Event Loop가 콜백 실행

**이번 실험에서 검증할 것:**

- 타이머는 백그라운드에서 진행되는가?
- Call Stack 블로킹이 타이머에 영향을 주는가?
- setTimeout의 시간은 "정확한 시간"인가, "최소 시간"인가?

---

## 핵심 검증 사항

이 실험으로 다음을 확인:

1. **타이머의 독립성**
   - 타이머는 Call Stack과 독립적으로 작동하는가?

2. **setTimeout 시간의 의미**
   - 1000ms = "정확히 1초 후"?
   - 1000ms = "최소 1초 후, Call Stack이 비면"?

3. **브라우저 멀티쓰레딩**
   - JavaScript는 싱글쓰레드
   - 하지만 타이머는 다른 쓰레드에서 실행?
