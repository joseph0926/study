# 실험 1.1: 함수 호출의 물리적 실체

## 최상위 질문

함수가 중첩되어 호출될 때, 실행 순서는 어떻게 결정되는가?

## 실험 코드

```javascript
function third() {
  console.log("3번");
}

function second() {
  console.log("2번 시작");
  third();
  console.log("2번 끝");
}

function first() {
  console.log("1번 시작");
  second();
  console.log("1번 끝");
}

first();
```

## 당신의 예측

**출력 순서를 예측하세요:**

```
1번 시작 -> 2번 시작 -> 3번 -> 2번 끝 -> 1번 끝
```

**예측한 이유:**

```
자바스크립트는 싱글쓰레드이므로 한번에 하나의 일만 가능함 -> 따라서 모든 함수가 비동기 함수가 아니므로 함수가 시작되면 끝날때까지(함수안에서 return을 만나거나 더이상 실행할 코드라인이 없는 경우) 다음 라인으로(실행 완료된 함수를 호출한 함수에서의 호출 라인의 다음 라인) 넘어가지 않을거라 예상했음.
따라서 first 함수에서 second() 라인을 만나면 second() 함수가 완료되어야(console.log("2번 끝")이 출력된 후) 다음 라인인 1번 끝으로 넘어갈것 (third 함수도 마찬가지)
```

**대안 가설 (최소 1개 이상):**

```
혹시 다르게 동작할 가능성은?

- 제 예상과 다르게 함수 안에서 다른 함수 호출이 기존 함수 코드 모두 실행 후 실행될때
- 그러면 이렇게될것: 1번 시작 -> 1번 끝 -> 2번 시작 -> 2번 끝 ->  3번
```

---

## 사고 체크 (교정 받을 영역)

**사용한 용어 점검:**

- [ ] "먼저/나중" 같은 모호한 표현 사용했는가?
- [ ] "호출"과 "실행"을 구분했는가?
- [ ] "끝난다"는 정확히 무엇을 의미하는가?

**가정 점검:**

- [ ] 숨겨진 가정이 있는가? (예: "위에서 아래로 실행된다")
- [ ] 그 가정은 검증 가능한가?

---

## 실험 실행

(아래는 실험 후 작성)

**실제 결과:**

```
1번 시작 -> 2번 시작 -> 3번 -> 2번 끝 -> 1번 끝
```

---

## 분석

**예측과 일치/불일치:**

```
일치
```

**왜 그런 결과가 나왔는가?**

```
1. 함수가 실행되면 함수가 콜스택에 쌓임
2. 함수가 return을 만나면 콜스택에서 제거됨
3. 함수에 명시적으로 return이 작성되어있지 않아도 마지막 라인 밑에 return이 있음
4. 콜스택은 선입후출임 > 나중에 쌓인게 먼저 처리됨
5. 따라서 먼저 first 함수가 콜스택에 먼저 올라가고, first 함수 실행중 second 함수가 콜스택에 올라가고, second 함수 실행 중 third 함수가 콜스택에 올라감, third 함수의 `console.log("3번");` 실행 후 그 아래 생략된 return에 의해 third 함수가 콜스택에서 제거되고, second, first도 마찬가지로 진행됨
```

**틀렸다면, 어떤 가정이 잘못되었나?**

```
일치하였음
```

---

## 새로운 질문

**이 실험에서 생긴 새로운 의문:**

```
- 만약에 엄청 라인이 긴 함수이거나 엄청 오래걸리는 함수가 콜스택에 올라가있으면 밑에 콜스택에 쌓여있는 코드들은 실행이 지연될것 > 그러면 만약에 끝나지 않는게 올라가있으면 아래는 아예 실행이 안되나? 아니면 js 자체적으로 콜스택에 올라가있는게 너무 오래걸리면 제거하나? > 그러면 그 기준은?
- 동시성 문제는 없는지? > 가능한지는 모르겠지만 정말 동시에 콜스택에 올라가면 어떻게되는지? > 실제로 가능한 일인지?
- 위에서 "쌓임"과 "제거됨"이라는 표현을 사용하고있는데 "누가"가 빠져있음 누가 쌓고 제거하는지?
- 콜스택에 한계가 존재하는지? > 즉 무한히 쌓일수있는지?
```

**다음 실험 아이디어:**

```
(실험 후 작성)
```
