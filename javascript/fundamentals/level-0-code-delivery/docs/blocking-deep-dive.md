# "블로킹"의 정확한 의미 파헤치기

## 당신의 설명:
> "JS는 싱글쓰레드이므로 한번에 한가지 일만 가능"

### 🤔 질문: 이 설명에서 검증할 부분들

#### 1. "JS는 싱글쓰레드"
- **정말 그런가?**
  - JS 엔진 자체가 싱글쓰레드?
  - 브라우저 전체가 싱글쓰레드?
  - Web Workers는 어떻게 동작하는가?

- **검증 필요:**
  - [ ] "싱글쓰레드"가 정확히 무엇을 의미하는가?
  - [ ] 어떤 "쓰레드"를 말하는가? (실행 쓰레드? 이벤트 루프? UI 쓰레드?)

#### 2. "한번에 한가지 일만 가능"
- **정말 한가지만?**
  - 네트워크 요청은?
  - 타이머는?
  - 렌더링은?

- **당신이 말한 상황에서:**
  ```
  HTML 파싱 중 → <script src> 만남 → 파싱 멈춤 → JS 다운로드
  ```

- **질문들:**
  - "JS 다운로드"는 누가 하는가? JS 엔진? 브라우저?
  - 다운로드 중에도 JS 엔진이 일하는가?
  - 다운로드는 "JS 작업"인가 "네트워크 I/O 작업"인가?

#### 3. "파싱 멈추고 다운받는 일을 진행"
- **정확히 무엇이 멈추는가?**
  - HTML 파싱만?
  - 렌더링도?
  - 다른 스크립트 다운로드도?

---

## 실험 0.4: 블로킹의 정확한 의미 밝히기

### 가설 세우기:

**당신의 모델:**
```
[HTML 파싱] → [<script src> 발견] → [파싱 멈춤] → [JS 다운로드] → [JS 실행] → [파싱 재개]
```

**질문:**
1. "JS 다운로드" 중에 JS 엔진은 뭘 하는가?
2. "파싱 멈춤"과 "JS 실행"은 같은 이유로 일어나는가?
3. 만약 JS 파일이 매우 크다면 (예: 10초 다운로드) 그 동안 브라우저는?

### 검증 방법:
- 큰 JS 파일로 테스트 (인위적으로 다운로드 지연)
- Network 탭의 타임라인 분석
- Performance 탭으로 실제 쓰레드 활동 확인

---

## 정밀한 모델 만들기

### 브라우저의 구조 (추상화):
```
브라우저
├── 메인 쓰레드 (UI Thread)
│   ├── HTML 파싱
│   ├── CSS 파싱
│   ├── 렌더링
│   └── JavaScript 실행
│
├── 네트워크 쓰레드들
│   └── HTTP 요청/응답 처리
│
└── 기타 쓰레드들
    ├── 이미지 디코딩
    └── ...
```

**핵심 질문:**
- "JS는 싱글쓰레드"는 정확히 어느 부분을 말하는가?
- "블로킹"은 어느 쓰레드의 어떤 작업을 막는가?

---

## 당신의 사고과정 개선 포인트:

### ✅ 좋은 점:
- 인과관계를 명확히 설명함
- "왜냐하면" 부분을 항상 포함
- 단계별로 나눠서 설명

### 🎯 개선할 점:
1. **용어의 정확한 정의**
   - "싱글쓰레드" → 정확히 어떤 쓰레드?
   - "블로킹" → 무엇이 무엇을 블로킹?

2. **숨겨진 가정 찾기**
   - "JS 다운로드"를 JS 엔진이 한다고 가정하지 않았나?
   - "한가지 일"의 범위가 명확한가?

3. **대안 모델 검토**
   - 만약 네트워크 I/O가 별도 쓰레드라면?
   - 그렇다면 "블로킹"의 이유는 다른 것 아닐까?

---

## 다음 단계:

실험 0.2와 0.3을 실행해보고:
1. 실제 결과 기록
2. 예측과 다른 부분 찾기
3. **"왜 다른가?"**에서 새로운 모델 구축
