# 레벨 0 정리: 스크립트 로딩 메커니즘

## ✅ 검증된 사실들

### 실험을 통해 직접 확인한 것:

#### 1. 일반 스크립트 (`<script src="...">`)
```
HTML 파싱 → <script> 만남 → 파싱 중단 → 다운로드 → 실행 → 파싱 재개
```

**관찰:**
- ✅ 다운로드 시작: 태그 만나는 즉시
- ✅ HTML 파싱: **블로킹됨**
- ✅ 실행 시점: 다운로드 완료 직후
- ✅ 렌더링: 다운로드 중에는 밑의 HTML이 화면에 안 보임

**타이밍:**
```
0ms: HTML 파싱 시작
→ <script src> 만남
→ 파싱 중단
→ 다운로드 대기 (2초)
2000ms: 다운로드 완료 → 즉시 실행
→ 파싱 재개
```

---

#### 2. async 스크립트 (`<script src="..." async>`)
```
HTML 파싱 → <script async> 만남 → 백그라운드 다운로드 시작 → 파싱 계속
                                                        ↓
                                              다운로드 완료 시 즉시 실행
```

**관찰:**
- ✅ 다운로드 시작: 태그 만나는 즉시
- ✅ HTML 파싱: **블로킹 안 됨** (병렬 진행)
- ✅ 실행 시점: 다운로드 완료 직후 (파싱 중이든 후든 상관없음)
- ✅ 렌더링: 다운로드 중에도 밑의 HTML이 보임

**타이밍:**
```
0ms: HTML 파싱 시작
→ <script async> 만남
→ 백그라운드 다운로드 시작
→ 파싱은 멈추지 않고 계속 진행
→ 2000ms: 다운로드 완료 → 그 순간 실행 (파싱 중단하고)
```

---

#### 3. defer 스크립트 (`<script src="..." defer>`)
```
HTML 파싱 → <script defer> 만남 → 백그라운드 다운로드 시작 → 파싱 계속
                                                        ↓
                                            파싱 완료 대기 → 실행
```

**관찰:**
- ✅ 다운로드 시작: 태그 만나는 즉시
- ✅ HTML 파싱: **블로킹 안 됨** (병렬 진행)
- ✅ 실행 시점: HTML 파싱 완료 후
- ✅ 렌더링: 다운로드 중에도 밑의 HTML이 보임

**타이밍:**
```
0ms: HTML 파싱 시작
→ <script defer> 만남
→ 백그라운드 다운로드 시작
→ 파싱은 멈추지 않고 계속 진행
1006ms: HTML 파싱 완료
→ 이제 defer 스크립트 실행 (다운로드는 이미 완료됨)
```

---

## 🎯 핵심 차이 요약

| 속성 | 다운로드 | HTML 파싱 블로킹 | 실행 시점 |
|------|----------|------------------|-----------|
| **없음** | 즉시 시작 | ✅ **블로킹** | 다운로드 직후 |
| **async** | 즉시 시작 | ❌ 블로킹 안 함 | 다운로드 직후 (언제든) |
| **defer** | 즉시 시작 | ❌ 블로킹 안 함 | HTML 파싱 완료 후 |

---

## 🧠 사고과정 개선 포인트

### 당신이 한 실수 (그리고 배운 것):

#### 1. **실험 조건의 중요성**
```
❌ 로컬 파일 (file://) → 다운로드가 너무 빨라 차이 안 보임
✅ 서버 + 인위적 지연 → 차이가 명확히 보임
```

**교훈**: "안 보인다" ≠ "없다". 관찰하려는 현상이 보이도록 조건을 조작해야 함.

---

#### 2. **"블로킹"의 정확한 의미**

**당신의 초기 모델:**
> "JS는 싱글쓰레드이므로 한번에 한가지 일만 가능"

**실제로 발견한 것:**
```
일반 스크립트:
  - HTML 파싱 쓰레드가 블로킹됨
  - 다운로드는 네트워크 쓰레드가 담당 (별도)
  - 블로킹 이유: "실행"을 위해 대기

async/defer:
  - HTML 파싱 쓰레드가 블로킹 안 됨
  - 다운로드는 백그라운드에서 병렬로
  - 차이는 "실행 시점"
```

**교훈**: "블로킹"은 무엇이 무엇을 블로킹하는지 명확히 해야 함.

---

#### 3. **다운로드 vs 실행의 분리**

**이전에 혼동했던 것:**
```
"async는 비동기로 로드한다" ← 모호함
```

**이제 정확히 아는 것:**
```
async:
  - 다운로드: 백그라운드 (비동기)
  - 실행: 다운로드 완료 즉시 (언제든)

defer:
  - 다운로드: 백그라운드 (비동기)
  - 실행: HTML 파싱 완료 후 (지연)
```

**교훈**: 추상적 용어("비동기", "지연")를 구체적 동작으로 쪼개야 함.

---

## 🤔 남은 질문들

### 1. "왜" 이렇게 설계되었을까?

**일반 스크립트가 블로킹하는 이유:**
- 역사적: 과거에는 스크립트가 `document.write()` 사용
- `document.write()`는 HTML 파싱 중에 문서를 수정
- 따라서 순서 보장이 필요 → 블로킹

**async의 용도:**
- 순서가 중요하지 않은 스크립트 (analytics, ads)
- 최대한 빨리 실행하고 싶을 때

**defer의 용도:**
- 순서가 중요한 스크립트 (라이브러리 의존성)
- DOM 전체가 필요한 스크립트
- 페이지 로딩 속도 개선

---

### 2. async 스크립트의 실행 순서

**질문**: 여러 async 스크립트가 있으면?
```html
<script src="a.js" async></script>
<script src="b.js" async></script>
<script src="c.js" async></script>
```

**예측**:
- 다운로드 완료 순서대로 실행?
- 선언 순서대로 실행?

**검증 필요**: 실험 0.7로 확인해야 함

---

### 3. defer 스크립트의 실행 순서

**질문**: 여러 defer 스크립트는?
```html
<script src="a.js" defer></script>
<script src="b.js" defer></script>
<script src="c.js" defer></script>
```

**예측**:
- defer는 순서 보장? (a → b → c)
- 아니면 다운로드 완료 순?

**검증 필요**: 실험 0.7로 확인해야 함

---

## 다음 단계

이제 "코드가 브라우저에 도달하는 과정"을 완전히 이해했습니다.

**다음 질문:**
1. 도달한 코드를 브라우저는 어떻게 "읽는가"? (파싱)
2. 파싱된 코드는 어떤 형태로 변환되는가?
3. 실제로 어떻게 실행되는가?

→ **레벨 1**로 이동
